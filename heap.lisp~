;;;; heap.lisp

(in-package #:15-Puzzle-solver)

(defstruct (heap (:constructor %make-heap (compare-fn &key key)))
  "Structure for storing the type (min/max-heap) and heap itself"
  ;; Function for o
  (order-fn (if (null key)
		compare-fn
	      (lambda (x y)
		  (funcall compare-fn (funcall key x) (funcall key y)))))
  (heap-structure (make-array 0 :adjustable t :fill-pointer t)))

(defun make-heap (compare-fn &key key initial-values)
  "Make a new heap data structure and insert the initial-values into it"
  (let ((heap (%make-heap compare-fn :key key)))
    (map nil #'(lambda (value)
		 (insert-heap value heap))
	 initial-values)
    heap))

(defun insert-heap (value heap)
  "Insert a given value into a heap"
  (with-slots (order-fn heap-structure) heap
    (let ((i (vector-push-extend value heap-structure))
	  
	  ))))

(defun remove-heap (heap)
  "Remove the topmost element of the heap and return it"
  (with-slots (order-fn heap-structure) heap
    (if (> (length heap-structure) 0)
	(let ((root (aref heap-structure 0)))
	  (setf (aref heap-structure 0) (vector-pop heap-structure))
	  root)
	nil)))

(defun peek-heap (heap)
  "Only return the topmost element of the heap"
  (aref heap 0))

(defun empty-heap (heap)
  "Remove all elements from the heap"
  (with-slots (heap-structure) heap
    (setf (fill-pointer heap-structure) 0)))

(defun percolate-up (heap posn)
  (with-slots (order-fn heap-structure) heap
    (cond
      ((and (/= posn 0)
	    (not (funcall order-fn
			  (aref heap-structure parent-posn)
			  (aref heap-structure posn)
			  )))
       (rotatef (aref heap-structure posn)
		(aref heap-structure parent-posn))
       (percolate-up heap parent-posn)
       )
      (t
       posn))))
